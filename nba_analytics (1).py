# -*- coding: utf-8 -*-
"""NBA Analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-qsbUikKWcgOG5npr40dlCPqC3V4nNyx
"""

from google.colab import drive
drive.mount('/content/gdrive')

"""# CODE

"""

from sklearn.linear_model import LogisticRegression
import pandas as pd
from math import *
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

df = pd.read_csv('/content/gdrive/MyDrive/playoff_shots.csv')
df.head()

df.drop(['SECONDS_REMAINING','SHOT_ZONE_AREA','SHOT_ZONE_RANGE','SHOT_ATTEMPTED_FLAG','EVENT_TYPE', 
         'GAME_DATE','HTM','VTM','MINUTES_REMAINING','PERIOD','TEAM_NAME','TEAM_ID','PLAYER_ID',
         'GAME_EVENT_ID','GAME_ID','GRID_TYPE'],inplace=True,axis=1)
df.iloc[200:205]

def f(row):
    if row['SHOT_MADE_FLAG'] == 0:
        val = 0
    elif row['SHOT_TYPE'] == '2PT Field Goal':
        val = 2
    else:
        val = 3
    return val

df['Points'] = df.apply(f, axis=1)

tables = pd.pivot_table(df,index=['SHOT_DISTANCE'],values=['SHOT_MADE_FLAG','Points'],aggfunc='count').reset_index()
point_table = pd.pivot_table(df, index='SHOT_DISTANCE', values = ['SHOT_MADE_FLAG'], aggfunc='count' ).reset_index()
#tables.plot.line(subplots=True)
tables.Points.plot.line(title='Shots vs Distance')

df.drop(df[df.SHOT_DISTANCE.astype(int) < 4 ].index, inplace=True)
df.drop(df[df.SHOT_DISTANCE.astype(int) > 33 ].index, inplace=True)
df.iloc[230:241]

def three_pt_ev(data, dist):
        data.SHOT_TYPE = data.SHOT_DISTANCE.apply(lambda x: 3 if x > dist else 2)
        data.Points = data.SHOT_MADE_FLAG * data.SHOT_TYPE
        dout = pd.pivot_table(data,index='SHOT_TYPE', values='Points')  #total points inside(2pt) and outside(3pt) of dist
        print([dist,dout.Points.iloc[0],dout.Points.iloc[1]])   #EV of 2pt and 3pt when dist is the line
        return [dist,dout.Points.iloc[0],dout.Points.iloc[1]]

shotlst = []
for i in np.arange(24.0,37,1):
  shotlst.append(three_pt_ev(df,i))
return pd.DataFrame(shotlst, columns = ['distance','2pt_ev','3pt_ev'])

df.SHOT_TYPE = df.SHOT_DISTANCE.apply(lambda x: 3 if x > 24.2 else 2)
df.Points = df.SHOT_MADE_FLAG * df.SHOT_TYPE
dout = pd.pivot_table(df,index='SHOT_TYPE', values='Points')  #total points inside(2pt) and outside(3pt) of dist
print([27.2,dout.Points.iloc[0],dout.Points.iloc[1]])   #EV of 2pt and 3pt when dist is the line

#expected value of 2PT
E2 = 2*df[(df.Points == 2) & (df.SHOT_ZONE_BASIC != 'Restricted Area')].shape[0] / df[(df.SHOT_TYPE == '2PT Field Goal')&(df.SHOT_ZONE_BASIC != 'Restricted Area')].shape[0]
E2

mlist = []
nlist=[]
for i in np.arange(25,31,1):
  df.ACTION_TYPE = df.SHOT_DISTANCE.apply(lambda x: 3 if x > i else 2)
  df.Points = df.SHOT_MADE_FLAG * df.ACTION_TYPE
  E3 = 3*df[(df.Points == 3)].shape[0]/ df[(df.ACTION_TYPE == 3)].shape[0]
  mlist.append(i)
  nlist.append(E3)

plt.plot(mlist,nlist)

steph = df[df.PLAYER_NAME == 'Stephen Curry']
steph_distr = steph.SHOT_DISTANCE.apply(lambda x: 3 if x>26 else 2)
steph_points = steph_distr* steph.SHOT_MADE_FLAG
steph_EV3 = 3* df[df.steph.points !=0].count() /df[df.steph_distr==3].count()

steph = df[df.PLAYER_NAME == 'Kevin Durant']
d=list(steph.SHOT_DISTANCE)
steph.head()

current_pct = steph[steph.Points == 3 & steph.SHOT_MADE_FLAG == 1].count() / steph[steph.Points == 3].count()
steph.Points = steph.SHOT_DISTANCE.apply(lambda x: 3 if x>26, 2 else)
modified_pct = steph[steph.Points == 3 & steph.SHOT_MADE_FLAG == 1].count() / steph[steph.Points == 3].count()

steph[steph.Points == 2].count()[0]

# This function is taken from Naveen Venkatesan's post. You can access it from:
# https://towardsdatascience.com/make-a-simple-nba-shot-chart-with-python-e5d70db45d0d

def create_court(ax, color):
    
    # Short corner 3PT lines
    ax.plot([-220, -220], [0, 140], linewidth=2, color=color)
    ax.plot([220, 220], [0, 140], linewidth=2, color=color)
    
    # 3PT Arc
    ax.add_artist(mpl.patches.Arc((0, 140), 440, 315, theta1=0, theta2=180, facecolor='none', edgecolor=color, lw=2))
    
    # Lane and Key
    ax.plot([-80, -80], [0, 190], linewidth=2, color=color)
    ax.plot([80, 80], [0, 190], linewidth=2, color=color)
    ax.plot([-60, -60], [0, 190], linewidth=2, color=color)
    ax.plot([60, 60], [0, 190], linewidth=2, color=color)
    ax.plot([-80, 80], [190, 190], linewidth=2, color=color)
    ax.add_artist(mpl.patches.Circle((0, 190), 60, facecolor='none', edgecolor=color, lw=2))
    
    # Rim
    ax.add_artist(mpl.patches.Circle((0, 60), 15, facecolor='none', edgecolor=color, lw=2))
    
    # Backboard
    ax.plot([-30, 30], [40, 40], linewidth=2, color=color)
    
    # Remove ticks
    ax.set_xticks([])
    ax.set_yticks([])
    
    # Set axis limits
    ax.set_xlim(-250, 250)
    ax.set_ylim(0, 470)
    
    return ax



mpl.rcParams['font.family'] = 'Avenir'
mpl.rcParams['font.size'] = 18
mpl.rcParams['axes.linewidth'] = 2

# Create figure and axes
fig = plt.figure(figsize=(4, 3.76))
ax = fig.add_axes([0, 0, 1, 1])

# Draw court
ax = create_court(ax, 'black')

# Plot hexbin of shots
ax.hexbin(steph['LOC_X'], steph['LOC_Y'] + 60, gridsize=(30, 30), extent=(-300, 300, 0, 940), bins='log', cmap='Blues')

# Annotate player name and season
ax.text(0, 1.05, 'Kevin Durant\n2018 Playoffs', transform=ax.transAxes, ha='left', va='baseline')

# Save and show figure
plt.savefig('ShotChart.png', dpi=300, bbox_inches='tight')
plt.show()

make_pct_pps_dist = pd.pivot_table(df, index='SHOT_DISTANCE', values = ['SHOT_MADE_FLAG','Points'] ).reset_index()
make_pct_dist = pd.pivot_table(df, index='SHOT_DISTANCE', values = ['SHOT_MADE_FLAG'] ).reset_index()
make_pct_dist_cnt = pd.pivot_table(df, index='SHOT_DISTANCE', values = ['SHOT_MADE_FLAG'], aggfunc='count' ).reset_index()
make_pct_dist_cnt.columns = ['SHOT_DISTANCE','SHOT_COUNT']

threes = make_pct_dist_cnt[make_pct_dist_cnt['SHOT_DISTANCE'] > 23]
threes['shot_pct'] = threes.SHOT_COUNT / threes.SHOT_COUNT.sum()

three_range = df[df.SHOT_DISTANCE > 22]
log_reg = LogisticRegression(solver='lbfgs')
log_reg.fit(three_range.SHOT_DISTANCE.values.reshape(-1, 1),three_range.SHOT_MADE_FLAG.values.reshape(-1, 1))
print('Score: ',log_reg.score(three_range.SHOT_DISTANCE.values.reshape(-1, 1),three_range.SHOT_MADE_FLAG.values.reshape(-1, 1)))

predicted_fgm_pct = log_reg.predict_proba(np.array(24).reshape(1,-1))
actual_fgm_pct = float(make_pct_dist[make_pct_dist['SHOT_DISTANCE'] == 26].SHOT_MADE_FLAG)
print('predicted: ', predicted_fgm_pct[0][1], ' actual: ',actual_fgm_pct)

new_distribution = threes
plot_data = []

for i in range(1,300):
        new_distribution.SHOT_DIST = new_distribution.SHOT_DISTANCE.apply(lambda x: x + (i/10))  #regulates the four point line location
        new_distribution['proj_make_pct'] = new_distribution.SHOT_DIST.apply(lambda x: log_reg.predict_proba(np.array(x).reshape(-1,1))[0][1])
        #estimation of how many of the attempted shots are successful beyond the four point line
        new_distribution['EV'] = new_distribution.shot_pct*new_distribution.proj_make_pct*4  #Expected Value of 4
        points_per_shot = new_distribution.EV.sum()
        plot_data.append((25+i/10,points_per_shot))  #list of location and its EV

plot_data

